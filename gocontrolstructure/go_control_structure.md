# Go Control Structure

> Go 语言的控制结构，if、for、switch。

## 控制结构

1984 年图灵奖获得者、著名计算机科学家尼古拉斯·沃斯（Niklaus Wirth）提出过著名 的“**程序 = 数据结构 + 算法**”的公式。

Go 语 言的基本数据类型和复合数据类型，这些对应的就是公式中数据结构，通过这些数据类型可以建立起复杂的数据结构。 

那么公式中的算法呢？算法是对真实世界运作规律的抽象，是解决真实世界中问题的步骤。在计算机世界中，再复杂的算法都可以通过顺序、分支和循环这三种基本的控制结构构造出来。

顺序结构自然不用说了，要关注的主要是后面两个，聚焦于 Go 语言中的分支和循环这两种控制结构。 

那么 Go 语言对分支与循环两种控制结构的支持是怎么样的呢？

- 针对程序的分支结构，Go 提供了 if 和 switch-case 两种语句形式；
- 而针对循环结构，Go 只保留了 for 这一种循环 语句形式。



## Go 的分支结构

Go 语言是站在 C 语言等的肩膀之上诞生与成长起来的。Go 语 言继承了 C 语言的很多语法，这里就包括控制结构。但 Go 也不是全盘照搬，而是在继承 的基础上又加上了自己的一些优化与改进，比如：

- Go 坚持“一件事情仅有一种做法的理念”，只保留了 for 这一种循环结构，去掉了 C 语言中的 while 和 do-while 循环结构； 
- Go 填平了 C 语言中 switch 分支结构中每个 case 语句都要以 break 收尾的“坑”； 
- Go 支持了 type switch 特性，让“类型”信息也可以作为分支选择的条件； 
- Go 的 switch 控制结构的 case 语句还支持表达式列表，让相同处理逻辑的多个分支可 以合并为一个分支，等等。



## if

那么，Go 中的 if 语句又有什么创新点呢？

### Go 的 if 语句

先来认识一下 Go 中的 if 语句。 if 语句是 Go 语言中提供的一种分支控制结构，它也是 Go 中最常用、最简单的分支控制 结构。它会根据布尔表达式的值，在两个分支中选择一个执行。

#### if 单分支结构

先来看一个最简单的、单分支结构的 if 语句的形式：

```go
if boolean_expression {
  // 新分支
}

// 原分支
```

分支结构是传统结构化程序设计中的基础构件，这个 if 语句中的代码执行流程就等价于下面这幅流程图：

![image-20211227104129937](go_control_structure.assets/image-20211227104129937.png)

从图中可以看到，代码执行遇到 if 分支结构后，首先会对其中的布尔表达式 （boolean_expression）进行求值，如果求值结果为 true，那么程序将进入新分支执行， 如果布尔表达式的求值结果为 false，代码就会继续沿着原分支的路线继续执行。 

虽然各种编程语言几乎都原生支持了 if 语句，但 Go 的 if 语句依然有着自己的特点： 

- 第一，和 Go 函数一样，if 语句的分支代码块的左大括号与 if 关键字在同一行上，这也是 Go 代码风格的统一要求，gofmt 工具会帮助实现这一点； 
- 第二，if 语句的布尔表达式整体不需要用括号包裹，一定程度上减少了开发人员敲击键盘的次数。
- 而且，if 关键字后面的条件判断表达式的求值结果必须是布尔类型，即要么是 true，要么是 false：

```go
if runtime.GOOS == "linux" {
   println("we are on linux os")
}

if runtime.GOOS == "darwin" {
  println("we are on darwin os")
}
```

如果判断的条件比较多，可以用多个**逻辑操作符**连接起多个条件判断表达式，比如这 段代码就是用了多个逻辑操作符 && 来连接多个布尔表达式：

```go
if (runtime.GOOS == "linux") && (runtime.GOARCH == "amd64") && (runtime.Compiler != "gccgo") {
   println("we are using standard go compiler on linux os for amd64")
}

if (runtime.GOOS == "darwin") && (runtime.GOARCH == "amd64") && (runtime.Compiler != "gccgo") {
  println("we are using standard go compiler on darwin os for amd64")
}
```

除了逻辑操作符 && 之外，Go 还提供了**另外两个逻辑操作符**，总结到了这张表里。

![image-20211227104818341](go_control_structure.assets/image-20211227104818341.png)

上面示例代码中的**每个布尔表达式都被小括号括上**了，这又是什么原 因呢？

这是为了降低在阅读和理解这段代码时，面对操作符优先级的心智负担，这也是 个人的编码习惯。 

**Go 语言的操作符是有优先级**的。这里要记住，一元操作符，比如上面的逻辑非操作符， 具有最高优先级，其他操作符的优先级如下：

![image-20211227104946942](go_control_structure.assets/image-20211227104946942.png)

操作符优先级决定了操作数优先参与哪个操作符的求值运算，以下面代码中 if 语句的 布尔表达式为例：

```go
// if 判断示例 逻辑操作符优先级 不加()
a, b := false, true
if a && b != true {
   println("(a && b) != true")
   return
}
println("a && (b != true) == false") // 输出：a && (b != true) == false
```

执行这段代码会输出什么呢？第一次读这段代码的时候，可能会认为输出 (a && b) != true，但实际上得到的却是 a && (b != true) == false。这是为什么呢？ 

这段代码的关键就在于，if 后面的布尔表达式中的操作数 b 是先参与 && 的求值运算，还是先参与!= 的求值运算。根据前面的操作符优先级表，知道，**!= 的优先级要高于 &&**，因此操作数 b 先参与的是!= 的求值运算，这样 if 后的布尔表达式就**等价于 a && (b != true)** ，而不是最初认为的 (a && b) != true。 

如果有时候也会记不住操作符优先级，不用紧张。从学习和使用 C 语言开始，就记不住这么多操作符的优先级，况且不同编程语言的操作符优先级还可能有所不同，所以个人倾向在 if 布尔表达式中，使用带有小括号的子布尔表达式来清晰地表达判断条件。

这样做不仅可以消除了自己记住操作符优先级的学习负担，同时就像前面说的，当其他人阅读代码时，也可以很清晰地看出布尔表达式要表达的逻辑关系，这能让代码的可读性更好，更易于理解，不会因记错操作符优先级顺序而产生错误的理解。

除了上面的最简形式，Go 语言的 if 语句还有其他多种形式，比如二分支结构和多（N） 分支结构。 

#### if 二分支结构

二分支控制结构比较好理解。比如下面这个例子，当 boolean_expression 求值为 true 时，执行分支 1，否则，执行分支 2：

```go
// 二分支结构
if boolean_expression {
   // 分支1
} else {
   // 分支2
}
```

#### 多（N）分支结构

多分支结构由于**引入了 else if**，理解起来稍难一点点，它的标准形式是这样的：

```go
// 多分支结构
if boolean_expression1 {
   // 分支1
} else if boolean_expression2 {
   // 分支2
   // ... ...
} else if boolean_expressionN {
   // 分支N
} else {
   // 分支N+1
}
```

以下面这个四分支的代码为例，看看怎么**拆解这个多分支结构**：

```go
// 四分支结构
if boolean_expression1 {
   // 分支1
} else if boolean_expression2 {
   // 分支2
} else if boolean_expression3 {
   // 分支3
} else {
   // 分支4
}
```

要理解这个略复杂一些的分支结构，其实很简单。只需要把它做一下**等价变换**，变换为熟悉的二分支结构就好了，变换后的代码如下：

```go
// 四分支结构 等价变换
if boolean_expression1 {
   // 分支1
} else {
   if boolean_expression2 {
      // 分支2
   } else {
      if boolean_expression3 {
         // 分支3
      } else {
         // 分支4
      }
   }
}
```

这样等价转换后，得到一个层层缩进的二分支结构，通过上面对二分支的分析， 再来理解这个结构就十分容易了。 

### 支持声明 if 语句的自用变量 

无论是单分支、二分支还是多分支结构，都可以在 if 后的布尔表达式前，进行一些变量的声明，在 if 布尔表达式前声明的变量，叫它 if 语句的自用变量。

顾名思义，这些变量只可以在 if 语句的代码块范围内使用，比如下面代码中的变量 a、b 和 c：

```go
// if 语句的自用变量
func main() {
   if a, c := f(), h(); a > 0 {
      println(a)
   } else if b := f(); b > 0 {
      println(a, b)
   } else {
      println(a, b, c)
   }
}
```

可以看到自用变量声明的位置是在每个 if 语句的后面，布尔表达式的前面，而且，由于声明本身是一个语句，所以需要把它和后面的布尔表达式通过分号分隔开。 

这里又涉及到了**代码块与作用域的概念**。上面代码中声明的变量 a、b、c 都位于各级 if 的隐式代码块中，它们的作用域起始于它声明所在的代码块，并一直可扩展至嵌入到这个代码块的所有内层代码块中。 

在 if 语句中声明自用变量是 Go 语言的一个**惯用法**，这种使用方式直观上可以让开发者有一种代码行数减少的感觉，提高可读性。同时，由于这些变量是 if 语句自用变量，它的作用域仅限于 if 语句的各层隐式代码块中，if 语句外部无法访问和更改这些变量，这就让这些变量具有一定**隔离性**，这样在阅读和理解 if 语句的代码时也可以更聚焦。 

Go 控制结构与短变量声明的结合是**“变量遮蔽”问题**出没的重灾区，在这点上一定要注意。 



### if 语句的“快乐路径”原则 

已经学了 if 分支控制结构的三种形式了，从可读性上来看，单分支结构要优于二分支结构，二分支结构又优于多分支结构。

那么显然，在日常编码中要减少多分支结构， 甚至是二分支结构的使用，这会有助于编写出优雅、简洁、易读易维护且不易错的代 码。

用一个具体的例子直观地体会一下这个观点，下面是两段逻辑相同但形式不同的 伪代码段：

```go
package ifhappypath

// 伪代码段1：
func doSomething() error {
   if errorCondition1 {
      // some error logic
      // ... ...
      return err1
   }
   // some success logic
   // ... ...
   if errorCondition2 {
      // some error logic
      // ... ...
      return err2
   }
   // some success logic
   // ... ...
   return nil
}

// 伪代码段2：
func doSomething() error {
   if successCondition1 {
      // some success logic
      // ... ...
      if successCondition2 {
         // some success logic
         // ... ...
         return nil
      } else {
         // some error logic
         // ... ...
         return err2
      }
   } else {
      // some error logic
      // ... ...
      return err1
   }
}
```

即便是刚入门的 Go 新手，大概也能看出上面代码的优劣。 

看看只使用了单分支控制结构的伪代码段 1，看到代码段 1 有这几个特点：

- 没有使用 else 分支，失败就立即返回； 
- “成功”逻辑始终“居左”并延续到函数结尾，没有被嵌入到 if 的布尔表达式为 true 的代码分支中；
-  整个代码段布局扁平，没有深度的缩进；

而另外一个实现了同样逻辑的伪代码段 2，就使用了带有嵌套的二分支结构，它的特点如 下：

- 整个代码段呈现为“锯齿状”，有深度缩进； 
- “成功”逻辑被嵌入到 if 的布尔表达式为 true 的代码分支中；

很明显，伪代码段 1 的逻辑更容易理解，也更简洁。Go 社区把这种 if 语句的使用方式称 为 **if 语句的“快乐路径（Happy Path）”原则**，所谓“快乐路径”也就是成功逻辑的代码执行路径，它的特点是这样的：

- 仅使用单分支控制结构； 
- 当布尔表达式求值为 false 时，也就是出现错误时，在单分支中快速返回； 
- 正常逻辑在代码布局上始终“靠左”，这样读者可以从上到下一眼看到该函数正常逻辑的全貌； 
- 函数执行到最后一行代表一种成功状态。

Go 社区推荐 Gopher 们在使用 if 语句时尽量符合这些原则，如果函数实现代码不符合“快乐路径”原则，可以按下面步骤进行**重构**：

- 尝试将“正常逻辑”提取出来，放到“快乐路径”中； 
- 如果无法做到上一点，很可能是函数内的逻辑过于复杂，可以将深度缩进到 else 分支中的代码析出到一个函数中，再对原函数实施“快乐路径”原则。



### 小结

分支控制结构是构造现实中复杂算法的三大基础控制结构之一，Go 语言通过 if 与 switch 语句对分支控制结构提供了支持。

重点讲解了 if 语句，建议记住以 下几点： 

- 第一，if 语句是 Go 语言中最常用的分支控制语句，也是最简单的分支控制结构。if 语句通过对布尔表达式的求值决定了后续代码执行要进入的哪条分支。当需要复杂条件判断时，可以使用逻辑操作符连接多个布尔表达式，作为 if 语句的判断条件表达式。如果这么 做了，还要注意各个操作符的优先级，个人建议尽量用小括号对各个布尔表达式进行清晰地隔离，这样可以提升代码可读性。 
- 第二，Go 的 if 语句提供了多种使用形式，包括单分支、双分支以及多分支。多分支理解起来略有难度，可以将它等价转换为双分支来理解。 
- 第三，if 语句支持在布尔表达式前声明自用变量，这些变量作用域仅限于 if 语句的代码块内部。使用 if 自用变量可以一定程度简化代码，并增强与同函数内其他变量的隔离，但这也十分容易导致变量遮蔽问题，使用时一定要注意。 
- 最后一点，if 语句的三种使用形式的复杂度与可读性不一，建议在使用 if 语句时尽量符合“快乐路径”原则，这个原则通常只使用最容易理解的单分支结构，所有正常代码 均“靠左”，这让函数内代码逻辑一目了然，提升了代码可读性与可维护性。



### 思考题 

思考题：如果一个 if 语句使用了多分支结构，如下面代码这样，那 么 if 语句中的几个布尔表达式如何排列能达到最好的效果呢？ 

提示一下，几个布尔表达式能够被命中的概率是不同的。

```go
func foo() {
   if boolean_expression1 {
      
   } else if boolean_expression2 {
      
   } else if boolean_expression3 {
      
   } else {
      
   }
}
```

- 如果加上“布尔表达式3在这段代码中实际被命中的机会更多，布尔表达式2次之，布尔表达式1最少” 这个条件，那么最优的性能最好的写法应该是**最大概率的放到最前面**，因此可以改成如下：

- ```go
  func foo() {
     if boolean_expression3 {
  
        return
     }
     if boolean_expression2 {
  
        return
     }
     if boolean_expression1 {
  
        return
     }
  
     // else代码
     return
  }
  ```

- 那为什么命中的最多，写到前面，是最好的呢，这里面主要涉及到2个技术点：流水线技术和分支预测

  - 流水线技术：简单的说，一条 CPU 指令的执行是由 取指令-指令译码-指令执行-结果回写 组成的(简单的说哈，真实的流水线是更长更复杂的)；第一条指令译码的时候，就可以去取第二条指令，因此可以通过流水线技术提高CPU的使用率。

  - 分支预测：如果没有任何分支预测，那么就是按照程序的代码顺序执行，那么执行到 if 上一句的时候，指令译码就是if语句，取指令就是if语句块的第一句，那么if 如果不满足的话，就会执行 JMP 指令，跳转到else，因此流水线中的取指令与指令译码其实是无用功。因此在没有任何分支预测优化的情况下，if 语句需要把概率更高的条件写到最上面，更能体现流水线的威力。

  - 但是现代计算机都有分支预测的优化，比如动态分支预测等技术，但是不管怎么说，把概率最大的放到最上面，还是很有必要的。

  - 问题：在C语言中，有类似这样的宏定义，可以使用 __builtin_expect函数，主动提示那个分支的代码的概率更高，在go中是否也有类似的方法？还是说现在的编后端编译技术已经比较智能，不需要甚至禁止程序员手动指定分支预测了。__

  - ```c
    #define likely(x) __builtin_expect(!!(x), 1)
    #define unlikely(x) __builtin_expect(!!(x), 0)
    ```



## for

针对程序的分支结构，Go 提供了 if 和 switch-case 两种语句形式。

虽然 switch-case 分支结构也非常重要，但毕竟已经有了 if 分支语句的基础了，很多时候用 if 也可以替代 switch-case，所以把它往后放放。

日常编码过程中，常常需要**重复执行同一段代码**，这时就需要循环结构来控制程序的执行顺序。一个循环结构会执行循环体中的代码直到结尾，然后回到开头继 续执行。 

主流编程语言都提供了对循环结构的支持，绝大多数主流语言，包括 C 语言、 C++、Java 和 Rust，甚至连动态语言 Python 还提供了不止一种的循环语句，但 Go 却只有一种，也就是 for 语句。 

### for 语句的经典使用形式 

C 语言是很多现代编程语言的“祖先”，要学习 Go 语言中 for 语句的使用形式，要 先看看 C 语言中 for 语句是怎么使用的。 

#### C 语言

下面这段 C 代码就是 **C 语言中 for 语句**的经典使用形式：

```c
#include <stdio.h>

int main() {
    int i;
    int sum = 0;
    for (i = 0; i < 10; i++) {
        sum += i;
    }
    printf("%d\n", sum);  // 45
}
```

#### Go 语言

这种形式也被其它后继语言延承了下来，Go 语言的 for 语句也不例外，这段 C 代码在 Go 语言中的等价形式是这样的：

```go
func main() {
   // for 语句
   var sum int
   for i := 0; i < 10; i++ {
      sum += i
   }
   println(sum) // 45
}
```

这种 for 语句的使用形式是 Go 语言中 for 循环语句的经典形式。

用一幅流程图来直观解释一下上面这句 for 循环语句的组成部分，以及各个部分的执行顺序：

![image-20211227184042910](go_control_structure.assets/image-20211227184042910.png)

从图中可以看到，经典 for 循环语句有四个组成部分（分别对应图中的①~④）。按顺 序拆解一下这张图。 

- 图中①对应的组成部分执行于循环体（③ ）之前，并且在整个 for 循环语句中**仅会被执行 一次**，它也被称为**循环前置语句**。通常会在这个部分声明一些循环体（③ ）或循环控制条件（② ）会用到的自用变量，也称循环变量或迭代变量，比如这里声明的整型变量 i。与 if 语句中的自用变量一样，for 循环变量也采用短变量声明的形式，循环变量的作用域仅限于 for 语句隐式代码块范围内。 
- 图中②对应的组成部分，是用来决定循环是否要继续进行下去的**条件判断表达式**。和 if 语 句的一样，这个用于条件判断的表达式必须为布尔表达式，如果有多个判断条件，一 样可以由逻辑操作符进行连接。当表达式的求值结果为 true 时，代码将进入循环体（③） 继续执行，相反则循环直接结束，循环体（③）与组成部分④都不会被执行。 
- 前面也多次提到了，图中③对应的组成部分是 for 循环语句的**循环体**。如果相关的判断条件表达式求值结构为 true 时，循环体就会被执行一次，这样的一次执行也被称为一次迭代（Iteration）。在上面例子中，循环体执行的动作是将这次迭代中变量 i 的值累加到变量 sum 中。
-  图中④对应的组成部分会在每次循环体迭代之后执行，也被称为循环后置语句。这个部分通常用于更新 for 循环语句组成部分①中声明的循环变量，比如在这个例子中，在这个组成部分对循环变量 i 进行加 1 操作。 

现在应该理解 Go 语言中的经典 for 语句的形式了吧？不过，Go 语言的 for 循环也在 C 语言的基础上有一些突破和创新。

#### 支持声明多循环变量

具体一点，Go 语言的 for 循环支持声明多循环变量，并且可以应用在循环体以及判断条件中，比如下面就是一个使用多循环变量的、稍复杂的例 子：

```go
// 声明多循环变量
for i, j, k := 0, 1, 2; (i < 20) && (j < 10) && (k < 30); i, j, k = i+1, j+1, k+5 {
   sum += (i + j + k)
   println(sum)
}
```

在这个例子中，声明了三个循环自用变量 i、j 和 k，它们共同参与了循环条件判断与循环体的执行。 

#### 省略后置循环语句

继续按四个组成部分分析这段代码。其实，除了循环体部分（③）之外，其余的三个部分都是**可选的**。

比如下面代码中，省略了循环后置语句④，将对循环变量的更新操 作放在了循环体中：

```go
// 省略后置循环语句
for i := 0; i < 10; {
   i++
}
```

#### 省略循环前置语句

也可以省略循环前置语句。比如下面例子中，就没有使用前置语句声明循环变 量，而是直接使用了已声明的变量 i 充当循环变量的作用：

```go
// 省略循环前置语句
i := 0
for ; i < 10; i++ {
   println(i)
}
```

#### 省略后置与前置语句

当然，循环前置与后置语句也可以都省略掉，比如下面代码：

```go
// 省略后置与前置语句
i := 0
for ; i < 10; {
  println(i)
  i++
}
```

虽然对前置语句或后置语句进行了省略，但经典 for 循环形式中的分号依然被保留着，要注意这一点，这是 Go 语法的要求。 

不过有一个**例外**，那就是当循环前置与后置语句都省略掉，仅保留循环判断条件表达式时，可以**省略经典 for 循环形式中的分号**。

也就是说，可以将上面的例子写出如 下形式：

```go
// 省略经典 for 循环形式中的分号
i := 0
for i < 10 {
   println(i)
   i++
}
```

这种形式也是在日常 Go 编码中经常使用的 for 循环语句的第二种形式，也就是除了循环体之外，仅保留循环判断条件表达式。 

#### 省略循环判断条件表达式（无限循环）

不过看到这里，可能就问了：“前面不是说过，除了循环体，其他组成部分都 是可选项么？” 

没错。当 for 循环语句的循环判断条件表达式的求值结果始终为 true 时，就可以将它省略掉了：

```go
// 省略循环判断条件表达式
for {
   // 循环体代码
   i += 6
}
```

这个 for 循环就是通常所说的**“无限循环”**。它的形式等价于：

```go
// 等价形式（无限循环）
for true {
   // 循环体代码
   i += 1
}
```

或者：

```go
// 等价形式（无限循环）
for ; ; {
   // 循环体代码
   i += 1
}
```

不过，虽然这里给出这些等价形式，但在日常使用时，还是建议用它的最简形式， 也就是for {...}，更加简单。 

那么，无限循环是什么意思呢？是不是意味着代码始终在运行循环体而无法跳出来呢？不是的。



### for range 循环形式 

for range 循环形式是怎么一种形式呢？

#### for range 循环（切片类型）

先来看一个例子。如果要使用 for 经典形式遍历一个切片中的元素，可以这样做：

```go
// for 经典形式 遍历切片中的元素
var sl = []int{1, 2, 3, 4, 5}
for i := 0; i < len(sl); i++ {
   fmt.Printf("sl[%d] = %d\n", i, sl[i])
}
```

在这个经典形式的例子中，使用循环前置语句中声明的循环变量 i 作为切片下标，逐一将切片中的元素读取了出来。不过，这样就有点麻烦了。

其实，针对像切片这样的复合 数据类型，还有 Go 原生的字符串类型（string），Go 语言提供了一个更方便的**“语法糖”形式：for range**。

现在就来写一个等价于上面代码的 for range 循环：

```go
// for range 形式 遍历切片中的元素
for i, v := range sl {
   fmt.Printf("sl[%d] = %d\n", i, v)
}
```

for range 循环形式与 for 语句经典形式差异较大，除了循环体保留了下来，其 余组成部分都“不见”了。其实那几部分已经被融合到 for range 的语义中了。 

具体来说，这里的 i 和 v 对应的是经典 for 语句形式中循环前置语句的循环变量，它们的初值分别为切片 sl 的第一个元素的下标值和元素值。

并且，隐含在 for range 语义中的循环控制条件判断为：是否已经遍历完 sl 的所有元素，等价于i < len(sl)这个布尔表达 式。

另外，每次迭代后，for range 会取出切片 sl 的下一个元素的下标和值，分别赋值给 循环变量 i 和 v，这与 for 经典形式下的循环后置语句执行的逻辑是相同的。 

for range 语句也有几个常见“变种”，继续以上面对切片的迭代为例分析一下。 

#### 省略元素值变量

变种一：当不关心元素的值时，可以省略代表元素值的变量 v，只声明代表下标值 的变量 i：

```go
// 省略元素值变量
for i := range sl {
   // ...
}
```

#### 空标识符代替下标变量

变种二：如果不关心元素下标，只关心元素值，那么可以用空标识符替代代表下 标值的变量 i。

这里一定要注意，这个空标识符不能省略，否则就与上面的“变种一”形式 一样了，Go 编译器将无法区分：

```go
// 空标识符代替下标变量
for _, v := range sl {
   // ...
}
```

#### 省略下标与元素值变量

变种三：到这里，肯定要问：如果既不关心下标值，也不关心元素值，那是否能写 成下面这样呢：

```go
// 省略下标与元素值变量
for _, _ = range sl {
   // ...
}
```

这种形式在语法上没有错误，就是看起来不太优雅。

Go 核心团队早在 Go 1.4 版本中就提供了一种**优雅的等价形式**，后续直接使用这种形式就好了：

```go
// 省略下标与元素值变量 优雅方式
for range sl {
   // ...
}
```



#### for range 循环（string 类型 ）

通过 for range 对一个字符串类型变量进行循环操作。通过下面的例子回顾一下：

```go
// for range 循环 string 类型
var s = "中国人"
for i, v := range s {
  fmt.Printf("%d %s 0x%x\n", i, string(v), v)
}
```

运行这个例子，输出结果是这样的：

```sh
0 中 0x4e2d
3 国 0x56fd
6 人 0x4eba
```

for range 对于 string 类型来说，每次循环得到的 **v 值是一个 Unicode 字符 码点**，也就是 rune 类型值，而不是一个字节，返回的第一个值 i 为**该 Unicode 字符码点的内存编码（UTF-8）的第一个字节在字符串内存序列中的位置**。 

另外，使用 **for 经典形式**与使用 for range 形式，对 string 类型进行循环操作的语义是不同的。 

```go
// for 经典形式
var t = "中国人"
for i := 0; i < len(t); i++ {
   fmt.Printf("index: %d, value: 0x%x\n", i, s[i])
}
// 输出
// index: 0, value: 0xe4
// index: 1, value: 0xb8
// index: 2, value: 0xad
// index: 3, value: 0xe5
// index: 4, value: 0x9b
// index: 5, value: 0xbd
// index: 6, value: 0xe4
// index: 7, value: 0xba
// index: 8, value: 0xba
```



#### for range 循环（map 类型）

map 就是一个键值对（key-value）集合，最常见的对 map 的操作，就是通过 key 获取其对应的 value 值。但有些时候，也要**对 map 这个集合进行遍历**，这就需要 for 语句的支持了。 

但在 Go 语言中，要对 map 进行循环操作，**for range 是唯一的方法**，for 经典循环形式是不支持对 map 类型变量的循环控制的。

下面是通过 for range，对一个 map 类型变量进行循环操作的示例：

```go
// for range 操作 map 类型变量
var m = map[string]int{
   "Rob":  67,
   "Russ": 39,
   "John": 29,
}

for k, v := range m {
   println(k, v)
}
```

运行这个示例，会看到这样的输出结果：

```sh
Russ 39
John 29
Rob 67
```

通过输出结果看到：for range 对于 map 类型来说，每次循环，循环变量 k 和 v 分别会被赋值为 map 键值对集合中一个元素的 key 值和 value 值（这个变量赋值是没有顺序的，随机赋值）。

而且，map 类型中没有下标的概念，通过 key 和 value 来循环操作 map 类型变量也就十分自然了。 

#### for range 循环（channel ）

除了可以针对 string、数组 / 切片，以及 map 类型变量进行循环操作控制之外，for range 还可以与 channel 类型配合工作。 

channel 是 Go 语言提供的并发设计的原语，它用于多个 Goroutine 之间的通信。

当 channel 类型变量作为 for range 语句的迭代对象时，for range 会尝试从 channel 中读取数据，使用形式是这样的：

```go
// for range 操作 channel 类型变量
var c = make(chan int)
for v := range c {
   // ...
}
```

在这个例子中，for range 每次从 channel 中读取一个元素后，会把它赋值给循环变量 v，并进入循环体。

当 channel 中没有数据可读的时候，for range 循环会阻塞在对 channel 的读操作上。直到 channel 关闭时，for range 循环才会结束，这也是 for range 循环与 channel 配合时隐含的循环判断条件。

在日常开发中，一旦执行 for 循环，是不是就只能等循环条件判断表达式求值为 false 时， 才能离开循环呢？如果是前面提到的无限循环，是不是就会被一直困于循环之中呢？ 

不是的。日常开发中，出于算法逻辑的需要，可能会有**中断当前循环体**并继续下一次迭代的时候，也会有中断循环体并彻底结束循环语句的时候。针对这些情况，Go 语言提供 了 continue 语句和 break 语句。



### 带 label 的 continue 语句 

如果循环体中的代码执行到一半，要中断当前迭代，忽略此迭代循环体中的后续代码，并回到 for 循环条件判断，尝试开启下一次迭代，这个时候可以怎么办呢？

可以使用 continue 语句来应对。 

#### continue 语句

先来学习一下 continue 语句的使用方法，看看下面这个代码示例：

```go
// continue 语句的使用方法
var sum int
var sl = []int{1, 2, 3, 4, 5, 6}
for i := 0; i < len(sl); i++ {
   if sl[i]%2 == 0 {
      // 忽略切片中值为偶数的元素
      continue
   }
   sum += sl[i]
}
println(sum) // 9
```

这段代码会循环遍历切片中的元素，把值为奇数的元素相加，然后存储在变量 sum 中。

可以看到，在这个代码的循环体中，如果判断切片元素值为偶数，就使用 continue 语句中断当前循环体的执行，那么循环体下面的sum += sl[i]在这轮迭代中就会被忽略。

代码执行流会直接来到循环后置语句i++，之后对循环条件表达式（i < len(sl)） 进行求值，如果为 true，将再次进入循环体，开启新一次迭代。 

如果学过 C 语言，可能会说：这个 continue 与 C 语言中的 continue 也没有什么差别啊！别急，Go 语言中的 continue 在 C 语言 continue 语义的基础上又**增加了对 label 的支持**。 

#### continue 语句 + label

label 语句的作用，是**标记跳转的目标**。可以把上面的代码改造为使用 label 的等价形式：

```go
package main

func main() {
   // continue 语句的使用方法 + label
   var sum int
   var sl = []int{1, 2, 3, 4, 5, 6}
loop:
   for i := 0; i < len(sl); i++ {
      if sl[i]%2 == 0 {
         // 忽略切片中值为偶数的元素
         continue loop
      }
      sum += sl[i]
   }
   println(sum) // 9
}
```

在这段代码中，定义了一个 label：loop，它标记的跳转目标恰恰就是 for 循环。也就是说，在循环体中可以使用 continue+ loop label 的方式来实现 循环体中断，这与前面的例子在语义上是等价的。

不过这里仅仅是一个演示，通常在这样非嵌套循环的场景中会直接使用不带 label 的 continue 语句。 

#### continue 语句 + label（嵌套循环语句）

而带 label 的 continue 语句，通常出现于**嵌套循环语句**中，被用于**跳转到外层循环并继续执行外层循环语句的下一个迭代**，比如下面这段代码：

```go
package main

import "fmt"

func main() {
   // continue 语句的使用方法 + label 嵌套循环语句
   var sl = [][]int{
      {1, 34, 26, 35, 78},
      {3, 45, 13, 24, 99},
      {101, 13, 38, 7, 127},
      {54, 27, 40, 83, 81},
   }
   
outerloop:
   for i := 0; i < len(sl); i++ {
      for j := 0; j < len(sl[i]); j++ {
         if sl[i][j] == 13 {
            fmt.Printf("found 13 at [%d, %d]\n", i, j)
            continue outerloop
         }
      }
   }
}
```

在这段代码中，变量 sl 是一个元素类型为[]int 的切片（二维切片），其每个元素切片中至多包含一个整型数 13。main 函数的逻辑就是在 sl 的每个元素切片中找到 13 这个数字， 并输出它的具体位置信息。

那这要怎么查找呢？一种好的实现方式就是，只需要**在每个切片中找到 13，就不用继续在这个切片的剩余元素中查找了**。 

用 for 经典形式来实现这个逻辑。面对这个问题，要使用嵌套循环，具体来说就 是外层循环遍历 sl 中的元素切片，内层循环遍历每个元素切片中的整型值。一旦内层循环发现 13 这个数值，便要中断内层 for 循环，回到外层 for 循环继续执行。 

如果用不带 label 的 continue 能不能完成这一功能呢？答案是不能。因为它只能中断内层循环的循环体，并继续开启内层循环的下一次迭代。

而带 label 的 continue 语句是这个场景下的“最佳人选”，它会直接结束内层循环的执行，并回到外层循环继续执行。 

这一行为就好比在外层循环放置并执行了一个不带 label 的 continue 语句。它会中断外层循环中当前迭代的执行，执行外层循环的后置语句（i++），然后再对外层循环的循环控制条件语句进行求值，如果为 true，就将继续执行外层循环的新一次迭代。 

看到这里，一些学习过 goto 语句的同学可能就会问了，如果把上述代码中的 continue **换成 goto 语句**，是否也可以实现同样的效果？ 

答案是**否定**的！一旦使用 goto 跳转，那么不管是**内层循环还是外层循环都会被终结**，代 码将会从 outerloop 这个 label 处，开始重新执行嵌套循环语句，这与带 label 的 continue 的跳转语义是完全不同的。 

还要特别提醒，goto 是一种公认的、难于驾驭的语法元素，应用 goto 的代码可读性差、代码难于维护还易错。虽然 Go 语言保留了 goto，但不推荐使用 goto 语句。



### 带 label 的 break 语句

在前面的讲解中，可能也注意到了，无论带不带 label，continue 语句的本质都是继续循环语句的执行。

但日常编码中，还会遇到一些场景，在这些场景中，不仅要中断当前循环体迭代的进行，还要同时**彻底跳出循环**，终结整个循环语句的执行。

面对这样的场景，continue 语句就不再适用了，Go 语言提供了 break 语句来解决这个问 题。 

#### break 语句

先来看下面这个示例中 break 语句的应用：

```go
package main

func main() {
   // for break 语句的使用
   var sl = []int{5, 19, 6, 3, 8, 12}
   var firstEven int = -1
   // 找出整型切片sl中的第一个偶数
   for i := 0; i < len(sl); i++ {
      if sl[i]%2 == 0 {
         firstEven = sl[i]
         break
      }
   }

   println(firstEven) // 6
}
```

这段代码逻辑很容易理解，通过一个循环结构来找出切片 sl 中的第一个偶数，一旦找到就不需要继续执行后续迭代了。这个时候就通过 break 语句跳出了这个循环。 

#### break 语句 + label

和 continue 语句一样，Go 也**增加了break 语句对 label 的支持**。

而且，和前面 continue 语句一样，如果遇到**嵌套循环**，break 要想跳出外层循环，用不带 label 的 break 是不够，因为不带 label 的 break 仅能跳出其所在的最内层循环。要想实现外层循环的跳出，还需给 break 加上 label。

来看一个具体的例子：

```go
package main

import "fmt"

var gold = 38

func main() {
   // for break 语句的使用 + label
   var sl = [][]int{
      {1, 34, 26, 35, 78},
      {3, 45, 13, 24, 99},
      {101, 13, 38, 7, 127},
      {54, 27, 40, 83, 81},
   }

outerloop:
   for i := 0; i < len(sl); i++ {
      for j := 0; j < len(sl[i]); j++ {
         if sl[i][j] == gold {
            fmt.Printf("found gold at [%d, %d]\n", i, j)
            break outerloop
         }
      }
   }
}
```

这个例子和带 label 的 continue 语句的例子很像，main 函数的逻辑就是，在 sl 这个二维切片中找到 38 这个数字，并输出它的位置信息。

整个二维切片中至多有一个值为 38 的元素，所以只要通过嵌套循环发现了 38，就不需要继续执行这个循环了。

这时，通过带有 label 的 break 语句，就可以**直接终结外层循环**，从而从复杂多层次的嵌套循环中直接跳出，避免不必要的算力资源的浪费。 

好了，关于 Go 语言中 for 语句的相关语法，已经全部讲完了，通过 for 语句可以实现重复执行同一段代码的逻辑。针对原生字符串类型以及一些复合数据类 型，诸如数组 / 切片、map、channel 等，Go 还提供了 for range“语法糖”形式来简化 循环结构的编写。

不过，相较于分支结构，以 for 语句为代表的循环结构的逻辑要复杂许多。 在日常编码实践中，也会遇到一些与 for 循环语句相关的常见问题与“坑”点。 

### for 语句的常见“坑”与避坑方法 

for 语句的常见“坑”点通常和 for range 这个“语法糖”有关。

虽然 for range 的引入提升了 Go 语言的表达能力，也简化了循环结构的编写，但 for range 也不是“免费的午餐”，初学者在享用这道美味时，经常会遇到一些问题，下面就来看看这些常见的问题。 

#### 问题一：循环变量的重用 

for range 形式的循环语句，使用短变量声明的方式来声明循环变量，循环体将使用这些循环变量实现特定的逻辑，但在刚开始学习使用的时候，可能会发现循环 变量的值与之前的“预期”不符，比如下面这个例子：

```go
package main

import (
   "fmt"
   "time"
)

func main() {
   var m = []int{1, 2, 3, 4, 5}

   for i, v := range m {
      go func() {
         time.Sleep(time.Second * 3)
         fmt.Println(i, v)
      }()
   }
   time.Sleep(time.Second * 10)
}
```

这个示例是对一个整型切片进行遍历，并且在每次循环体的迭代中都会创建一个新的 Goroutine（Go 中的轻量级协程），输出这次迭代的元素的下标值与元素值。

作为一个初学者，预期的输出结果可能是这样的：

```sh
0 1
1 2
2 3
3 4
4 5
```

那实际输出真的是这样吗？实际运行输出一下：

```sh
4 5
4 5
4 5
4 5
4 5
```

Goroutine 中输出的循环变量，也就是 i 和 v 的值都是 for range 循环结束后的最终值，而不是各个 Goroutine 启动时变量 i 和 v 的值，与最初的“预期”不符， 这是为什么呢？ 

这是因为最初的“预期”本身就是错的。这里，初学者很可能会被 for range 语句中 的短声明变量形式“迷惑”，简单地认为每次迭代都会重新声明两个新的变量 i 和 v。但事实上，这些**循环变量在 for range 语句中仅会被声明一次，且在每次迭代中都会被重用**。

基于隐式代码块的规则， 可以将上面的 for range 语句做一个**等价转换**，这样可以帮助理解 for range 的工作原理。等价转换后的结果是这样的：

```go
package main

import (
   "fmt"
   "time"
)

func main() {
   // for range 循环变量的重用 的 等价转换
   var m = []int{1, 2, 3, 4, 5}

   {
      i, v := 0, 0
      for i, v = range m {
         go func() {
            time.Sleep(time.Second * 3)
            fmt.Println(i, v)
         }()
      }
   }
   time.Sleep(time.Second * 10)
}
```

通过等价转换后的代码，可以清晰地看到循环变量 i 和 v 在每次迭代时的重用。

而 Goroutine 执行的闭包函数引用了它的外层包裹函数中的变量 i、v，这样，变量 i、v 在主 Goroutine 和新启动的 Goroutine 之间实现了共享，而 **i, v 值在整个循环过程中是重用的**，仅有一份。

> 备注：上述一共会启动 len(m) 个Goroutine.

在 for range 循环结束后，i = 4, v = 5，因此各个 Goroutine 在等待 3 秒后进行输出的时候，输出的是 i, v 的最终值。 

那么如何修改代码，可以让实际输出和最初的预期输出一致呢？

可以**为闭包函数增加参数**，并且**在创建 Goroutine 时将参数与 i、v 的当时值进行绑定**，看下面的修正代 码：

```go
package main

import (
   "fmt"
   "time"
)

func main() {
   // for range 循环变量的重用 的 修改(绑定参数 i，v)
   var m = []int{1, 2, 3, 4, 5}

   for i, v := range m {
      go func(i, v int) {
         time.Sleep(time.Second * 3)
         fmt.Println(i, v)
      }(i, v)
   }

   time.Sleep(time.Second * 10)
}
```

运行修改后的例子代码，输出结果是这样的：

```sh
0 1
1 2
2 3
3 4
4 5

# 备注：由于 goroutine 属于并发执行，后续的输出不一定是完全按照切片的顺序，但是数据的内容没错。
```

这回的输出结果与预期就是一致的了。

不过这里要注意：执行这个程序的输出结果的行序，可能与这里的不同，这是由 Goroutine 的调度所决定的。 

#### 问题二：参与循环的是 range 表达式的副本 

在 for range 语句中，range 后面接受的表达式的类型可以是**数组、指向数组的指针、切片、字符串，还有 map 和 channel（需具有读权限）**。

以数组为例来看一个简单的例子：

```go
package main

import "fmt"

func main() {
   // 参与循环的是 range 表达式的副本
   var a = [5]int{1, 2, 3, 4, 5}
   var r [5]int

   fmt.Println("original a =", a)

   for i, v := range a {
      if i == 0 {
         a[1] = 12
         a[2] = 13
      }
      r[i] = v
   }

   fmt.Println("after for range loop, r =", r)
   fmt.Println("after for range loop, a =", a)
}
```

这个例子说的是对一个数组 a 的元素进行遍历操作，当处理下标为 0 的元素时，修改了数组 a 的第二个和第三个元素的值，并且在每个迭代中，都将从 a 中取得的元素值赋值给新数组 r。

期望这个程序会输出如下结果：

```sh
original a = [1 2 3 4 5]
after for range loop, r = [1 12 13 4 5]
after for range loop, a = [1 12 13 4 5]
```

但实际运行该程序的输出结果却是：

```sh
original a = [1 2 3 4 5]
after for range loop, r = [1 2 3 4 5]
after for range loop, a = [1 12 13 4 5]
```

原以为在第一次迭代过程，也就是 i = 0 时，对 a 的修改 (a[1] =12,a[2] = 13) 会 在第二次、第三次迭代中被 v 取出，但从结果来看，v 取出的依旧是 a 被修改前的值：2 和 3。 

为什么会是这种情况呢？原因就是**参与 for range 循环的是 range 表达式的副本**。

也就是说，在上面这个例子中，真正参与循环的是 a 的副本，而不是真正的 a。 为了方便理解，将上面的例子中的 for range 循环，用一个**等价的伪代码**形式重写 一下：

```go
for i, v := range a' { //a'是a的一个值拷贝
    if i == 0 {
        a[1] = 12
        a[2] = 13
    }

    r[i] = v
}
```

现在真相终于揭开了：这个例子中，每次迭代的都是从数组 a 的**值拷贝 a’**中得到的元素。a’是 Go 临时分配的连续字节序列，与 a 完全不是一块内存区域。

因此无论 a 被如何修改，它参与循环的副本 a’依旧保持原值，因此 v 从 a’中取出的仍旧是 a 的原值，而不是修改后的值。 

那么应该如何解决这个问题，让输出结果符合预期呢？

在 Go 中，大多数应用数组的场景都可以**用切片替代**，这里也用切片来试试看：

```go
package main

import "fmt"

func main() {
   // 参与循环的是 range 表达式的副本 的 修改(使用切片替代数组)
   var a = [5]int{1, 2, 3, 4, 5}
   var r [5]int

   fmt.Println("original a =", a)

   for i, v := range a[:] {
      if i == 0 {
         a[1] = 12
         a[2] = 13
      }
      r[i] = v
   }
   
   fmt.Println("after for range loop, r =", r)
   fmt.Println("after for range loop, a =", a)
}
```

你可以看到，在 range 表达式中，用了 a[:]替代了原先的 a，也就是将数组 a 转换为一个切片，作为 range 表达式的循环对象。

运行这个修改后的例子，结果是这样的：

```sh
original a = [1 2 3 4 5]
after for range loop, r = [1 12 13 4 5]
after for range loop, a = [1 12 13 4 5]
```

输出的结果与最初的预期终于一致了，显然用切片能实现要求。 

那切片是如何做到的呢？切片在 Go 内部表示为一个结构体，由（array, len, cap）组成，其中 array 是指向切片对应的底层数组的指针，len是切片当前长度，cap 为切片的最大容量。 

所以，当进行 range 表达式复制时，实际上复制的是一个切片，也就是表示切片的结构体。表示切片副本的结构体中的 array，依旧指向原切片对应的底层数组，所以对切片副本的修改也都会反映到底层数组 a 上去。

而 v 再从切片副本结构体中 array 指向的底层数组中，获取数组元素，也就得到了被修改后的元素值。 



#### 问题三：遍历 map 中元素的随机性 

根据上面的讲解，当 map 类型变量作为 range 表达式时，得到的 map 变量的副本与原变量指向同一个 map。

如果在循环的过程中，对 map 进行了修改，那么这样修改的结果是否会影响后续迭代呢？这个结果和遍历 map 一样，具有**随机性**。 

比如来看下面这个例子，在 map 循环过程中，当 counter 值为 0 时，删除了变 量 m 中的一个元素：

```go
package main

import "fmt"

func main() {
   // 遍历 map 中元素的随机性
   var m = map[string]int{
      "tony": 21,
      "tom":  22,
      "jim":  23,
   }

   counter := 0
   for k, v := range m {
      if counter == 0 {
         delete(m, "tony")
      }
      counter++
      fmt.Println(k, v)
   }
   fmt.Println("counter is ", counter)
}
```

如果反复运行这个例子多次，会得到两个不同的结果。当 k="tony"作为第一个迭代的元素时，将得到如下结果：

```sh
tony 21
tom 22
jim 23
counter is  3
```

否则，得到的结果是这样的：

```sh
jim 23
tom 22
counter is  2
```

如果在针对 map 类型的循环体中，新创建了一个 map 元素项，那这项元素**可能出现在后续循环中**，也可能不出现：

```go
package main

import "fmt"

func main() {
   // 新创建一个 map 元素项
   var m = map[string]int{
      "tony": 21,
      "tom": 22,
      "jim": 23,
   }

   counter := 0
   for k, v := range m {
      if counter == 0 {
         m["lucy"] = 24
      }
      counter++
      fmt.Println(k, v)
   }
   fmt.Println("counter is ", counter)
}
```

这个例子的执行结果也会有两个，

```sh
tom 22
jim 23
lucy 24
tony 21
counter is  4
```

或者：

```sh
tony 21
tom 22
jim 23
counter is  3
```

考虑到上述这种随机性，日常编码遇到遍历 map 的同时，还需要对 map 进行修改的场景的时候，要格外小心。 

> 可以尝试改进map，将其变成有序 map。
>
> 对map迭代的实质是按顺序逐个bucket的遍历,每个bucket也是逐个遍历其中的key。如果lucy创建于第一个被遍历的元素之前了，那么后续就不会遍历它了。
>
> 别忘了，key存储在哪里是根据hash值来定的。是否访问到，视m["lucy"]=24这个键值对的插入位置而定。



### 小结 

和其他主流编程语言不同，Go 语言仅提供了一种循环结构语句：for 语句。

for 语句的这种践行“做一件事仅有一种方法”理念的作法恰是 Go 语言崇尚“简单”的设计哲学的具体体现。 

首先学习了 for 语句的经典形式：for preStmt; condition; postStmt { … }，要注意 for 语句经典形式的四个组成部分，分别是循环前置语句、循环判断表达式、循环体与循环后置语句，也要注意这四个部分的执行顺序。

而且，这四部分中，除了循环体，其它三个组成部分都是可选的。可以根据实际情况选择省略某个部分。 

- 如果只保留循环判断条件表达式，就得到了 for 循环语句经常使用的第二种形 式：for condition {...}。
- 如果循环判断条件表达式求值结果始终为 true，就可以将 for 循环语句写成for {...}的形式，这种形式也被称为“无限循环”。 

而且，针对 string 类型以及一些复合数据类型，比如数组 / 切片、map 以及 channel 等，Go 提供了使用更为便捷的“语法糖”for range 形式。

- for range 形式与 for 语句经 典形式差异较大，除了循环体保留了下来，其它几部分融合到 for range 的语义中了。
- for range 语句形式也有几个“变种”，要注意的是，如果仅需要代表元素值的循环变量， 不需要代表下标值或 key 的循环变量，也需要使用空标识符占位。

此外，Go 语言提供了 continue 语句与 break 语句用于显式中断当前循环体的执行，两个语句不同之处在于 continue 会继续后续迭代的执行，而 break 将终结整个 for 语句的执行。

Go 语言还支持在 continue 与 break 关键字后面加 label 的方式，这种方式常用于有嵌套循环的场景中，它们可以帮助程序中断内层循环的执行，返回外层循环继续执行下一 个外层循环迭代，或彻底结束整个嵌套循环的执行。 

最后，for 语句在日常使用中有一些常见的问题需要格外注意，包括循环变量重用、 range 表达式副本参与循环、map 类型遍历的随机性，等等。

### 思考题 

在“参与循环的是 range 表达式的副本”这一部分中，用切片替换了数组，实现了预期的输出，除了换成切片这个方案之外，还有什么方案也能实现预期的输出呢？

- 用数组指针替换数组

- ```go
  package main
  
  import "fmt"
  
  func main() {
     // 参与循环的是 range 表达式的副本 的 修改(使用数组指针替代数组)
     var a = [5]int{1, 2, 3, 4, 5}
     var r [5]int
  
     fmt.Println("original a =", a)
  
     for i, v := range &a { // a 改为 &a
        if i == 0 {
           a[1] = 12
           a[2] = 13
        }
        r[i] = v
     }
  
     fmt.Println("after for range loop, r =", r)
     fmt.Println("after for range loop, a =", a)
  
  }
  ```



## switch







































































































































